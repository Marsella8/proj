from proj.config_file import (
    ProjectConfig,
    gen_ifndef_uid,
    get_include_path,
    get_source_path,
    with_suffixes,
)
from proj.format import run_formatter
from os import PathLike
from typing import (
    TextIO,
    Sequence,
    Iterator,
    Optional,
)
from pathlib import Path
from .render import (
    render_header,
    render_source,
)
from .spec import (
    StructSpec,
    load_spec,
)
import logging

_l = logging.getLogger(__name__)

def find_files(root: Path) -> Iterator[Path]:
    patterns = ['*.struct.toml']
    blacklist = [
        root / 'triton',
        root / 'deps',
    ]
    
    def is_blacklisted(p: Path) -> bool:
        for blacklisted in blacklist:
            if found.is_relative_to(blacklisted):
                return True
        return False

    for pattern in patterns:
        for found in root.rglob(pattern):
            if not is_blacklisted(found):
                yield found

# def guess_header_path(spec_path: Path):
#     pass

# def guess_src_path(spec_path: Path):
#     pass

def render_disclaimer(spec_path: Path, root: Path, f: TextIO) -> None:
    f.write('// THIS FILE WAS AUTO-GENERATED BY proj. DO NOT MODIFY IT!\n')
    f.write('// If you would like to modify this datatype, instead modify\n')
    f.write(f'// {spec_path.relative_to(root)}\n')

def generate_header(spec: StructSpec, spec_path: Path, root: Path, out: Path) -> None:
    out.parent.mkdir(exist_ok=True, parents=True)
    with out.open('w') as f:
        ifndef = gen_ifndef_uid(out)
        render_disclaimer(spec_path=spec_path, root=root, f=f)
        f.write('\n')
        f.write(f'#ifndef {ifndef}\n')
        f.write(f'#define {ifndef}\n')
        f.write('\n')
        render_header(spec=spec, f=f)        
        f.write('\n')
        f.write(f'#endif // {ifndef}\n')

def generate_source(spec: StructSpec, spec_path: Path, root: Path, out: Path) -> None:
    out.parent.mkdir(exist_ok=True, parents=True)
    with out.open('w') as f:
        render_disclaimer(spec_path=spec_path, root=root, f=f)
        f.write('\n')
        f.write(f'#include "{get_include_path(out)}"\n')
        f.write('\n')
        render_source(spec=spec, f=f)

def generate_files(root: Path, config: ProjectConfig, spec_path: Path) -> Sequence[Path]:
    spec = load_spec(spec_path)
    source_path = get_source_path(spec_path)
    header_path = with_suffixes(spec_path, config.header_extension)
    generate_header(spec=spec, spec_path=spec_path, root=root, out=header_path)
    generate_source(spec=spec, spec_path=spec_path, root=root, out=source_path)
    return [header_path, source_path]

def run_dtgen(root: Path, config: ProjectConfig, files: Optional[Sequence[PathLike[str]]] = None) -> None:
    if files is None:
        files = list(find_files(root))
    _l.info('Running dtgen on following files:')
    for f in files:
        _l.info(f'- {f}')
    for spec_path in files:
        generated = generate_files(root=root, config=config, spec_path=Path(spec_path))
        run_formatter(root, generated)
